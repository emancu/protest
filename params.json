{"tagline":"A tiny, simple, and easy-to-extend test framework","body":"# Protest [<img src=\"https://secure.travis-ci.org/matflores/protest.png?branch=master\" alt=\"Build Status\" />](http://travis-ci.org/matflores/protest)\r\n\r\n```ruby\r\nrequire \"protest\"\r\n\r\nProtest.describe(\"A user\") do\r\n  setup do\r\n    @user = User.new(name: \"John Doe\", email: \"john@example.org\")\r\n  end\r\n\r\n  it \"has a name\" do\r\n    assert_equal \"John Doe\", @user.name\r\n  end\r\n\r\n  it \"has an email\" do\r\n    assert_equal \"john@example.org\", @user.email\r\n  end\r\nend\r\n```\r\n\r\nProtest is a small, simple, and easy-to-extend testing framework for ruby. It\r\nwas written as a replacement for Test::Unit, given how awful its code is, and\r\nhow difficult it is to extend in order to add new features.\r\n\r\nI believe in minimalistic software, which is easily understood, easy to test,\r\nand specially, easy to extend for third parties. That's where I'm aiming with\r\nProtest.\r\n\r\n## Get it\r\n\r\n```\r\ngem install protest\r\n```\r\n\r\n## Setup and teardown\r\n\r\nIf you need to run code before or after each test, declare a `setup` or\r\n`teardown` block:\r\n\r\n```ruby\r\nProtest.context(\"A user\") do\r\n  setup do # this runs before each test\r\n    @user = User.create(name: \"John\")\r\n  end\r\n\r\n  teardown do # this runs after each test\r\n    @user.destroy\r\n  end\r\nend\r\n```\r\n\r\n`setup` and `teardown` blocks are evaluated in the same context as your test,\r\nwhich means any instance variables defined in any of them are available in the\r\nrest. Both methods are aliased for your comfort as `before` and `after` respectively.\r\n\r\n## Nested contexts\r\n\r\nBreak down your test into logical chunks with nested contexts:\r\n\r\n```ruby\r\nProtest.describe(\"A user\") do\r\n  setup do\r\n    @user = User.make\r\n  end\r\n\r\n  context \"when validating\" do\r\n    it \"validates name\" do\r\n      @user.name = nil\r\n      assert !@user.valid?\r\n    end\r\n\r\n    # etc, etc\r\n  end\r\n\r\n  context \"doing something else\" do\r\n    # you get the idea\r\n  end\r\nend\r\n```\r\n\r\nAny `setup` or `teardown` blocks you defined in a context will run in that\r\ncontext and in _any_ other context nested in it.\r\n\r\n## Pending tests\r\n\r\nThere are two ways of marking a test as pending. You can declare a test with no\r\nbody:\r\n\r\n```ruby\r\nProtest.context(\"Some tests\") do\r\n  test \"this test will be marked as pending\"\r\n\r\n  test \"this tests is also pending\"\r\n\r\n  test \"this test isn't pending\" do\r\n    assert true\r\n  end\r\nend\r\n```\r\n\r\nOr you can call the `pending` method from inside your test:\r\n\r\n```ruby\r\nProtest.context(\"Some tests\") do\r\n  test \"this test is pending\" do\r\n    pending \"oops, this doesn't work\"\r\n    assert false\r\n  end\r\nend\r\n```\r\n\r\n## Custom assertions\r\n\r\nPrevious versions of Protest used to bundle all the assertions defined in\r\nTest::Unit, but that has changed and now Protest includes just three basic\r\nassertion methods:\r\n\r\n- assert\r\n- assert_equal\r\n- assert_raise\r\n\r\nIf you want to add assertions, just define methods that rely on `assert`.\r\nThis method takes a boolean and an optional error message as arguments, and\r\nthe assertion is considered to fail if the boolean evaluates to neither\r\n`false` nor `nil`.\r\n\r\nFor example:\r\n\r\n```ruby\r\nmodule AwesomenessAssertions\r\n  def assert_awesomeness(object)\r\n    assert object.awesome?, \"#{object.inspect} is not awesome enough\"\r\n  end\r\nend\r\n\r\nclass Protest::TestCase\r\n  include AwesomenessAssertions\r\nend\r\n```\r\n\r\nYou could also define rspec-like matchers if you like that style. See\r\n`matchers.rb` in the examples directory for an example.\r\n\r\n## Reports\r\n\r\nProtest can report the output of a test suite in many ways. The library ships\r\nwith a few reports defined by default.\r\n\r\nYou can select which report to use using the `report_with` method:\r\n\r\n```ruby\r\nProtest.report_with(:documentation)\r\nProtest.report_with(:progress)\r\nProtest.report_with(:my_awesome_custom_report)\r\n```\r\n\r\nBy default, Protest will use the report defined in the `PROTEST_REPORT`\r\nenvironment variable. If this variable is not defined, the Documentation\r\nreport will be used.\r\n\r\n### Progress report\r\n\r\nUse this report by calling `Protest.report_with(:progress)`.\r\n\r\nThe progress report will output the \"classic\" Test::Unit output of periods for\r\npassing tests, \"F\" for failing assertions, \"E\" for unrescued exceptions, and\r\n\"P\" for pending tests, in full color.\r\n\r\n### Documentation report\r\n\r\nUse this report by calling `Protest.report_with(:progress)`.\r\n\r\nFor each testcase in your suite, this will output the description of the test\r\ncase (whatever you provide TestCase.context), followed by the name of each test\r\nin that context, one per line. For example:\r\n\r\n```ruby\r\nProtest.context \"A user\" do\r\n  test \"has a name\"\r\n  test \"has an email\"\r\n\r\n  context \"validations\" do\r\n    test \"ensure the email can't be blank\"\r\n  end\r\nend\r\n```\r\n\r\nWill output, when run with the `:documentation` report:\r\n\r\n```\r\nA user\r\n- has a name (Not Yet Implemented)\r\n- has an email (Not Yet Implemented)\r\n\r\nA user validations\r\n- ensure the email can't be blank (Not Yet Implemented)\r\n```\r\n\r\n(The 'Not Yet Implemented' messages are because the tests have no body. See\r\n\"Pending tests\", above.)\r\n\r\nThis is similar to the specdoc runner in [rspec](http://rspec.info).\r\n\r\n### Summary report\r\n\r\nUse this report by calling `Protest.report_with(:summary)`.\r\n\r\nThis report will output a brief summary with the total number of tests,\r\nassertions, passed tests, pending tests, failed tests and errors.\r\n\r\n### Stories report\r\n\r\nUse this report by calling `Protest.report_with(:stories)`.\r\n\r\nThis report is based on Citrusbyte's [Stories](http://github.com/citrusbyte/stories),\r\nby Damian Janowski and Michel Martens.\r\n\r\n### Turn report\r\n\r\nUse this report by calling `Protest.report_with(:turn)`.\r\n\r\nThis report displays each test on a separate line with failures being displayed\r\nimmediately instead of at the end of the tests.\r\n\r\nYou might find this useful when running a large test suite, as it can be very\r\nfrustrating to see a failure (....F...) and then have to wait until all the\r\ntests finish before you can see what the exact failure was.\r\n\r\nThis report is based on the output displayed by [TURN](http://github.com/TwP/turn),\r\nTest::Unit Reporter (New) by Tim Pease.\r\n\r\n### Defining your own reports\r\n\r\nThis is really, really easy. All you need to do is subclass `Report`, and\r\nregister your subclass by calling `Protest.add_report`. See the\r\ndocumentation for details, or take a look at the source code for\r\n`Protest::Reports::Progress` and `Protest::Reports::Documentation`.\r\n\r\n## Using Rails?\r\n\r\nIf you are using Rails you may want to take a look at [protest-rails](http://github.com/matflores/protest-rails).\r\n\r\n## Legal\r\n\r\n* Maintainer: Matías Flores — http://matflores.com\r\n* Author: Nicolás Sanguinetti — http://nicolassanguinetti.info\r\n* License: MIT (see bundled LICENSE file for more info)\r\n","google":"UA-34641064-2","note":"Don't delete this file! It's used internally to help with page regeneration.","name":"Protest"}